"
I am an abstruct class for decision diagram.
Index is supposed to be encoded by _literal encoding_.
"
Class {
	#name : 'DD',
	#superclass : 'Object',
	#instVars : [
		'graph'
	],
	#category : 'PropositionalLogic-DecisionDiagram',
	#package : 'PropositionalLogic',
	#tag : 'DecisionDiagram'
}

{ #category : 'instance creation' }
DD class >> newFromAssociation: anAssociation [

	<todo: 'normalize'>
	^ self new setGraphFromAssociation: anAssociation; reduce; yourself
]

{ #category : 'comparing' }
DD >> = other [

	^ graph = other graph
]

{ #category : 'composing' }
DD >> and: other [

    ^ self apply: [ :a :b | a & b ] unit: false with: other
]

{ #category : 'algorithm - private' }
DD >> apply: operator on: aGraph and: otherGraph withMapping: aMapping withValue: aTable [

    self subclassResponsibility
]

{ #category : 'algorithm' }
DD >> apply: anOperator unit: aBool with: other [
    "return a new diagram generated by applying anOperator, which unit is aBool, to me and other"

    | aGraph otherGraph mapping values |
    aGraph := graph deepCopy.
    otherGraph := other graph deepCopy.
    "mapping between terminal and nonterminal node and index"
    mapping := Dictionary newFrom:
                   ((aGraph allNodesSet inject: otherGraph allNodesSet
                         into: [ :set :node | set add: node; yourself ]) asOrderedCollection
                        withIndexCollect: [ :node :i | node -> (i + 2) ]).
    "Contract: embed anOperator at -1, aBool at 0, false at 1 and true at 2"
    mapping at: 0 put: aBool; at: false put: 1; at: true put: 2; at: false put: 1; at: true put: 2.
    values := Dictionary new at: 0 put: aBool; at: false put: false; at: true put: true; yourself.
    ^ self copy graph: (self apply: anOperator
                   on: aGraph
                   and: otherGraph
                   withMapping: mapping
                   withValue: values); reduce; yourself
]

{ #category : 'algorithm' }
DD >> compose: other at: anVarIndex [
    "return a new diagram defined as f_1|_{x_i=f_2}"

    | aGraph otherGraph mapping values |
    aGraph := graph deepCopy.
    otherGraph := other graph deepCopy.
    "mapping from terminal and nonterminal node to index"
    mapping := Dictionary newFrom:
                   ((aGraph allNodesSet inject: otherGraph allNodesSet
                         into: [ :set :node | set add: node; yourself ]) asOrderedCollection
                        withIndexCollect: [ :node :i | node -> (i + 2) ]).
    mapping at: 1 put: false; at: 2 put: true.
    "mapping from index to node. Contract: embed anVarIndex at 0, false at 1 and true at 2"
    mapping at: 0 put: anVarIndex; at: false put: false; at: true put: true.
    values := Dictionary new at: 0 put: anVarIndex; at: false put: false; at: true put: true;
                      yourself.
    ^ self copy graph: (self composeGraphLow: aGraph
                   high: aGraph
                   and: otherGraph
                   withMapping: mapping
                   withValue: values); reduce; yourself
]

{ #category : 'algorithm - private' }
DD >> composeGraphLow: vlow1 high: vhigh1 and: v2 withMapping: aMapping withValue: values [

    self subclassResponsibility
]

{ #category : 'accessing' }
DD >> graph [

	^ graph
]

{ #category : 'accessing' }
DD >> graph: anObject [

	graph := anObject
]

{ #category : 'comparing' }
DD >> hash [

	^ graph hash
]

{ #category : 'inspector extensions' }
DD >> inspectionGraph [

	<inspectorPresentationOrder: 10 title: 'Graph'>
	^ SpRoassalPresenter new canvas: self visualize; yourself
]

{ #category : 'composing' }
DD >> or: other [

	^ self apply: [ :a :b | a | b ] unit: true with: other
]

{ #category : 'algorithm' }
DD >> reduce [
    "reduce to canonical form"

    self reduce: graph
]

{ #category : 'algorithm - private' }
DD >> reduce: aGraph [
    "reduce to canonical form"

    self subclassResponsibility
]

{ #category : 'algorithm' }
DD >> restrict: aVarIndex to: aBool [
    "f|_{x_i=b}"

    graph allNodesSet do: [ :node |
        node varIndex = aVarIndex ifTrue: [
            aBool ifFalse: [ node low: false ] ifTrue: [ node high: true ] ] ].
    self reduce
]

{ #category : 'evaluating' }
DD >> satisfyAll [
	"S_f"

	self subclassResponsibility
]

{ #category : 'evaluating' }
DD >> satisfyCount [
	"|S_f|"

	self subclassResponsibility
]

{ #category : 'evaluating' }
DD >> satisfyOne [
	"some element of S_f"

	self subclassResponsibility
]

{ #category : 'initialization' }
DD >> setGraphFromAssociation: anAssociation [

	graph := DDNode newFromAssociation: anAssociation
]

{ #category : 'accessing' }
DD >> size [

	^ graph allNodesSet size
]

{ #category : 'accessing' }
DD >> valueUnder: anAssignment [
	"return bool"

	<TODO: 'Is this a good name'>
	self notYetImplemented
]

{ #category : 'drawing - roassal' }
DD >> visualize [
    "Draw top as a blue elipsse and bottom as a black one."

    | canvas elements nodes node |
    nodes := graph allNodesSet.
    elements := nodes collect: [ :each |
                    node := RSGroup new.
                    node add:
                        (RSEllipse new size: 10; color: Color white; borderColor: Color gray;
                                 yourself).
                    node translateBy: 0 @ -1; add:
                            (RSLabel new fontSize: 4; text: each varIndex; yourself).
                    node asShape model: each; draggable; yourself ].
    node := RSGroup new.
    node add: (RSEllipse new size: 10; color: Color white; borderColor: Color blue; yourself).
    node translateBy: 0 @ -1; add: (RSLabel new fontSize: 4; text: 'F'; yourself).
    elements add: (node asShape model: false; draggable; yourself).
    node := RSGroup new.
    node add: (RSEllipse new size: 10; color: Color white; borderColor: Color red; yourself).
    node translateBy: 0 @ -1; add: (RSLabel new fontSize: 4; text: 'T'; yourself).
    elements add: (node asShape model: true; draggable; yourself).
    elements := elements as: RSGroup.
    canvas := RSCanvas new addAll: elements; yourself.
    RSLineBuilder line dashed; moveBehind; canvas: canvas; width: 1; color: Color blue;
        connectFromAll: [ :each | nodes select: [ :n | n low == each ] ].
    RSLineBuilder line moveBehind; canvas: canvas; width: 1; color: Color red; connectFromAll: [
            :each | nodes select: [ :n | n high == each ] ].
    RSTreeLayout new on: elements.
    ^ canvas @ RSCanvasController; canvas
]
